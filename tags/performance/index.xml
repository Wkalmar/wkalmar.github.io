<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Bohdan Stupak&#39;s blog</title>
    <link>https://wkalmar.github.io/tags/performance/</link>
    <description>Recent content in Performance on Bohdan Stupak&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Oct 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wkalmar.github.io/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Strive for short-lived synchronous communication</title>
      <link>https://wkalmar.github.io/post/make-synchronous-communication-short-lived/</link>
      <pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/make-synchronous-communication-short-lived/</guid>
      <description>When interacting with a service asynchronous communication often is a preferred way. &amp;ldquo;Enterprise integration patterns&amp;rdquo; book puts it that way (which also might be a TL;DR; for the rest of the article)
 With synchronous communication, the caller must wait for the receiver to finish processing the call before the caller can receive the result and continue. In this way, the caller can only make calls as fast as the receiver can perform them.</description>
    </item>
    
    <item>
      <title>Prefer using Stream to byte[]</title>
      <link>https://wkalmar.github.io/post/prefer-stream-to-byte-array/</link>
      <pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/prefer-stream-to-byte-array/</guid>
      <description>When working with files there are often both APIs operating byte[] and Stream so quite often people chose byte[] counterpart as it requires less ceremony or just intuitively more clear.
You may think of this conclusion as far-fetched but I&amp;rsquo;ve decided to write about it after reviewing and refactoring some real-world production code. So you may find this simple trick neglected in your codebase as some other simple things I&amp;rsquo;ve mentioned in my previous articles.</description>
    </item>
    
    <item>
      <title>Batch processing with Directory.EnumerateFiles</title>
      <link>https://wkalmar.github.io/post/batch-processing-with-enumeratefiles/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/batch-processing-with-enumeratefiles/</guid>
      <description>In case one wants to retrieve files from catalog Directory.GetFiles is a simple answer sufficient for most scenarios. However, when you deal with a large amount of data you might need more advanced techniques.
Example Let&amp;rsquo;s assume you have a big data solution and you need to process a directory that contains 200000 files. For each file, you extract some basic info public record FileProcessingDto{public string FullPath { get; set; }public long Size { get; set; }public string FileNameWithoutExtension { get; set; }public string Hash { get; internal set; }}</description>
    </item>
    
    <item>
      <title>Using Span&lt;T&gt; to improve performance of C# code</title>
      <link>https://wkalmar.github.io/post/improving-performance-with-span/</link>
      <pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/improving-performance-with-span/</guid>
      <description>In my experience, the main thing to do in order to improve application performance is to reduce the number and duration of IO-calls. However, once this option is exercised another path that developers take is using memory on stack. Stack allows very fast allocation and deallocation although it should be used only for allocating small portions since stack size is pretty small. Also, using stack allows reducing pressure on GC.</description>
    </item>
    
  </channel>
</rss>