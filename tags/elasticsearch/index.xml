<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elasticsearch on Bohdan Stupak&#39;s blog</title>
    <link>https://wkalmar.github.io/tags/elasticsearch/</link>
    <description>Recent content in Elasticsearch on Bohdan Stupak&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 25 Dec 2022 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wkalmar.github.io/tags/elasticsearch/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Improving Elasticsearch-based autocomplete</title>
      <link>https://wkalmar.github.io/post/improving-autocomplete/</link>
      <pubDate>Sun, 25 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/improving-autocomplete/</guid>
      <description>Recently I&amp;rsquo;ve investigated autocomplete functionality of our system as there were a lot of complaints that it returns irrelevant results. The approach we&amp;rsquo;ve taken was pretty naive: our backend wrapped query into wildcard symbols and executed it as query_string on fields __title, title and commonInfo.RealName. Index we&amp;rsquo;ve executed search upon contained entity with _title equal 3 foxes but autocomplete query 3 foxes suggested BRN-3 / QCK 3 / 19 foxes, AC d / 3 foxes, 3 BRW / 1 foxes.</description>
    </item>
    
    <item>
      <title>Applying custom similarity calculation in Elasticsearch</title>
      <link>https://wkalmar.github.io/post/applying-custom-similarity-for-elasticsearch/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/applying-custom-similarity-for-elasticsearch/</guid>
      <description>Presently we&amp;rsquo;ve been discussing improving elasticsearch autocomplete functionality. For most cases, this is enough. However, in our case, things turned out to be not that rosy and we&amp;rsquo;ll have a look at why.
Setup In our system we single document type per index. Since we have quite a lot of types in our system and the number of types and their mappings can be changed by the end-user, we have unpredictable number of indices.</description>
    </item>
    
  </channel>
</rss>