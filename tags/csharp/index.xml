<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Csharp on Bohdan Stupak&#39;s blog</title>
    <link>https://wkalmar.github.io/tags/csharp/</link>
    <description>Recent content in Csharp on Bohdan Stupak&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wkalmar.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leader election with Redlock.net</title>
      <link>https://wkalmar.github.io/post/leader-election-with-redlock-net/</link>
      <pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/leader-election-with-redlock-net/</guid>
      <description>Why locking things Microservice architecture becomes widely adopted these days. One of the benefits it offers is the possibility of horizontal scaling which allows us to increase the performance of our application dramatically. However, there are situations when multiple instances of service face contention for some shared resource. Consider a service which apart from other functionality runs once per day some mission-critical job which should be executed in a single instance.</description>
    </item>
    
    <item>
      <title>Dependency Injection for Quartz.NET in .NET Core</title>
      <link>https://wkalmar.github.io/post/dependency-injection-for-quartz-net-in-net-core/</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/dependency-injection-for-quartz-net-in-net-core/</guid>
      <description>Introduction Quartz.NET is a handy library that allows you to schedule recurring tasks via implementing IJob interface. Yet the limitation of it is that, by default, it supports only parameterless constructor which complicates injecting external service inside of it, i.e., for implementing repository pattern. In this article, we&amp;rsquo;ll take a look at how we can tackle this problem using standard .NET Core DI container.
The whole project referred in the article is provided inside the following [Github repository]().</description>
    </item>
    
    <item>
      <title>&#34;Method can be made static&#34; May Hide OO Design Flaw</title>
      <link>https://wkalmar.github.io/post/method-can-be-made-static-may-hide-oo-design-flaw/</link>
      <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/method-can-be-made-static-may-hide-oo-design-flaw/</guid>
      <description>Introduction Wandering through codebases, I&amp;rsquo;ve encountered some examples of code where ReSharper issues the above mentioned warning. Although the fix seems straightforward, the warning itself may hide a more subtle issue connected to object responsibility assignment.
Toy Example Let&amp;rsquo;s take a look at the following code: public class EmailConstructor{private const string Signature = &amp;#34;Regards&amp;#34;;public string Construct(User recipient, string body){var builder = new StringBuilder();builder.Append($&amp;#34;Hello {GetNiceUserName(recipient)}&amp;#34;);builder.</description>
    </item>
    
    <item>
      <title>Registry Redirection when using 32-bit Application on 64-bit Windows</title>
      <link>https://wkalmar.github.io/post/registry-redirection-when-using-bit-application-on/</link>
      <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wkalmar.github.io/post/registry-redirection-when-using-bit-application-on/</guid>
      <description>This article will guide you through Windows registry redirection feature, which might seem quite unintuitive at first acquaintance. ##The Code Consider the following situation. We have code that writes to HKEY_LOCAL_MACHINE registry on 64-bit OS. var softwareSubKey = Registry.LocalMachine.OpenSubKey(&amp;#34;Software&amp;#34;, RegistryKeyPermissionCheck.ReadWriteSubTree);softwareSubKey.CreateSubKey(&amp;#34;MySoftware&amp;#34;);  When successfully executing this code, we somewhat unexpectedly receive no MySoftware folder at \HKEY_LOCAL_MACHINE\SOFTWARE path. After investigating build tab in project options, we discover the following:</description>
    </item>
    
  </channel>
</rss>